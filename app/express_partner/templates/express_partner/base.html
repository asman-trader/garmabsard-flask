<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>{% block title %}وینور اکسپرس | پنل همکاران{% endblock %}</title>

  {# --- Favicon & PWA (Separate from main VINOR) --- #}
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32x32.png') }}">
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
  {# مانیفست جداگانه برای Express Partner #}
  <link rel="manifest" href="{{ url_for('express_partner.manifest') }}">
  <meta name="theme-color" content="#7c3aed">

  <script>
    (function(){
      try {
        var root = document.documentElement;
        var saved = localStorage.getItem('theme');
        if (!saved) {
          var prefersDark = false;
          try { prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(_) {}
          saved = prefersDark ? 'dark' : 'light';
          try { localStorage.setItem('theme', saved); } catch(_) {}
        }
        if (saved === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
        var meta = document.querySelector('meta[name="theme-color"]');
        if (meta) meta.setAttribute('content', root.classList.contains('dark') ? '#7c3aed' : '#7c3aed');
      } catch(_) {}
    })();
  </script>

  {# iOS PWA #}
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" sizes="192x192" href="{{ url_for('static', filename='icons/icon-192.png') }}">

  {# --- CSS/Fonts --- #}
  <script>
    window.tailwind = window.tailwind || {};
    window.tailwind.config = { darkMode: 'class' };
  </script>
  <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//fonts.gstatic.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="font" href="{{ url_for('static', filename='vendor/fontawesome/webfonts/fa-solid-900.woff2') }}" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="{{ url_for('static', filename='vendor/fontawesome/webfonts/fa-regular-400.woff2') }}" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="{{ url_for('static', filename='vendor/fontawesome/webfonts/fa-brands-400.woff2') }}" type="font/woff2" crossorigin>
  <link rel="stylesheet" href="{{ url_for('static', filename='vendor/fontawesome/css/all.min.css') }}" onerror="this.parentNode.removeChild(this)">
  <link rel="stylesheet" href="{{ url_for('static', filename='fonts/vazirmatn.css') }}" onerror="this.parentNode.removeChild(this)">

  <script src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;700&display=swap" rel="stylesheet" />

  <style>
    html,body{overscroll-behavior-y:contain;overscroll-behavior-x:auto}
    body{font-family:'Vazirmatn',sans-serif;scroll-behavior:smooth}
    *, *::before, *::after{
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
    }
    .no-scrollbar{scrollbar-width:none}
    .no-scrollbar::-webkit-scrollbar{display:none}
    [x-cloak] { display: none !important; }
    {% block styles %}{% endblock %}
  </style>

  {% block head %}{% endblock %}
</head>
<body class="bg-gray-50 dark:bg-gray-950 text-gray-800 dark:text-gray-100">

  {% block content %}{% endblock %}

  <script>
    (function(){
      // ثبت Service Worker جداگانه برای Express Partner
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('{{ url_for("express_partner.service_worker") }}', { 
          scope: '/express/partner/',
          updateViaCache: 'none' 
        })
          .then(async (reg) => {
            try {
              await navigator.serviceWorker.ready;
              const sw = navigator.serviceWorker.controller || (await (async()=>{
                try { await reg.update(); } catch {} 
                return navigator.serviceWorker.controller;
              })());
              
              // Warmup Express Partner routes
              const urls = [
                '/express/partner/login',
                '/express/partner/dashboard',
                '/express/partner/profile',
                '/express/partner/commissions',
                '/express/partner/notes',
                '/express/partner/apply'
              ];
              
              if (sw) sw.postMessage({ type: 'VINOR_WARMUP', urls });
            } catch {} 
          })
          .catch(()=>{});
      }

      // --- PWA Install Hooks (Express Partner) ---
      let expressPartnerDeferredPrompt;

      // Handle PWA install prompt
      window.addEventListener('beforeinstallprompt', (e) => {
        // Only handle if it's for Express Partner scope
        const url = new URL(window.location.href);
        if (url.pathname.startsWith('/express/partner/')) {
          e.preventDefault();
          expressPartnerDeferredPrompt = e;

          // Show install button containers when PWA is available
          const installContainer = document.getElementById('expressPartnerInstall');
          const installMobileContainer = document.getElementById('expressPartnerInstallMobile');
          
          if (installContainer) installContainer.classList.remove('hidden');
          if (installMobileContainer) installMobileContainer.classList.remove('hidden');
        }
      });

      // Handle successful installation
      window.addEventListener('appinstalled', (evt) => {
        console.log('Express Partner PWA was installed successfully');
        expressPartnerDeferredPrompt = null;

        // Update install buttons after successful install
        const installBtn = document.getElementById('expressPartnerInstallBtn');
        const installMobileBtn = document.getElementById('expressPartnerInstallMobileBtn');
        
        if (installBtn) {
          installBtn.textContent = 'نصب شد';
          installBtn.disabled = true;
          installBtn.classList.add('opacity-50');
        }
        if (installMobileBtn) {
          installMobileBtn.textContent = 'نصب شد';
          installMobileBtn.disabled = true;
          installMobileBtn.classList.add('opacity-50');
        }
      });

      // PWA Install Button Handler
      document.addEventListener('DOMContentLoaded', function() {
        const installBtn = document.getElementById('expressPartnerInstallBtn');
        const installMobileBtn = document.getElementById('expressPartnerInstallMobileBtn');
        
        function handleInstall() {
          if (expressPartnerDeferredPrompt) {
            expressPartnerDeferredPrompt.prompt();
            expressPartnerDeferredPrompt.userChoice.then((choiceResult) => {
              if (choiceResult.outcome === 'accepted') {
                console.log('User accepted Express Partner PWA install');
              } else {
                console.log('User dismissed Express Partner PWA install');
              }
              expressPartnerDeferredPrompt = null;
            }).catch((error) => {
              console.error('Error during Express Partner PWA install:', error);
            });
          } else {
            // Fallback for browsers that don't support beforeinstallprompt
            alert('برای نصب اپلیکیشن وینور اکسپرس، از مرورگر کروم، اج یا فایرفاکس استفاده کنید.');
          }
        }

        if (installBtn) {
          installBtn.addEventListener('click', handleInstall);
        }
        if (installMobileBtn) {
          installMobileBtn.addEventListener('click', handleInstall);
        }
      });

      // Dark mode toggle
      document.addEventListener('DOMContentLoaded', function() {
        const darkToggle = document.getElementById('darkToggle');
        if (darkToggle) {
          darkToggle.addEventListener('click', function() {
            const root = document.documentElement;
            root.classList.toggle('dark');
            const isDark = root.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            const meta = document.querySelector('meta[name="theme-color"]');
            if (meta) meta.setAttribute('content', isDark ? '#7c3aed' : '#7c3aed');
          });
        }
      });
    })();
  </script>

  {# ===== Push Notifications Auto-Subscribe ===== #}
  <script>
    (function(){
      // VAPID Public Key از context processor
      const VAPID_PUBLIC_KEY = "{{ VAPID_PUBLIC_KEY|default('', true) }}";

      function urlBase64ToUint8Array(base64String) {
        const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
        const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
        const rawData = atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
        return outputArray;
      }

      async function requestPermission() {
        if (!("Notification" in window)) throw new Error("مرورگر شما از اعلان پشتیبانی نمی‌کند.");
        const perm = await Notification.requestPermission();
        if (perm !== "granted") throw new Error("اجازه اعلان داده نشد.");
        return perm;
      }

      async function getRegistration() {
        if (!('serviceWorker' in navigator)) throw new Error("Service Worker پشتیبانی نمی‌شود.");
        const reg = await navigator.serviceWorker.getRegistration('{{ url_for("express_partner.service_worker") }}');
        if (reg) return reg;
        return await navigator.serviceWorker.register('{{ url_for("express_partner.service_worker") }}', { scope: '/express/partner/' });
      }

      async function subscribePush() {
        await requestPermission();
        const reg = await getRegistration();
        const existing = await reg.pushManager.getSubscription();
        if (existing) return existing;
        if (!VAPID_PUBLIC_KEY) throw new Error("VAPID_PUBLIC_KEY تنظیم نشده است.");
        const appServerKey = urlBase64ToUint8Array(VAPID_PUBLIC_KEY);
        return await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: appServerKey });
      }

      async function saveSubscription(sub) {
        const res = await fetch("/api/push/subscribe", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify(sub),
        });
        if (!res.ok) throw new Error("ذخیره اشتراک ناموفق بود.");
        return await res.json();
      }

      // ===== فعال‌سازی خودکار اعلان‌ها در پس‌زمینه =====
      async function autoEnableNotificationsInBackground() {
        try {
          // بررسی لاگین بودن کاربر
          const isLoggedIn = {{ 'true' if session.get('user_phone') else 'false' }};
          if (!isLoggedIn) return;

          if (!('serviceWorker' in navigator) || !('Notification' in window)) return;
          if (!VAPID_PUBLIC_KEY) return;

          const NOTIFICATION_AUTO_ENABLED_FLAG = 'vinor_express_notifications_auto_enabled';
          const AUTO_PROMPT_DISMISSED = 'vinor_express_notifications_auto_prompt_dismissed';
          const lastPromptTime = localStorage.getItem('vinor_express_notifications_last_prompt');
          const dismissed = localStorage.getItem(AUTO_PROMPT_DISMISSED);

          // اگر کاربر قبلاً رد کرده یا کمتر از 24 ساعت پیش درخواست داده‌ایم، صبر کن
          if (dismissed === '1') return;
          if (lastPromptTime) {
            const hoursSinceLastPrompt = (Date.now() - parseInt(lastPromptTime)) / (1000 * 60 * 60);
            if (hoursSinceLastPrompt < 24) return;
          }

          const currentPerm = Notification.permission;

          // اگر اجازه داده نشده، در پس‌زمینه درخواست بده
          if (currentPerm === 'default') {
            try { localStorage.setItem('vinor_express_notifications_last_prompt', String(Date.now())); } catch(_) {}
            const perm = await Notification.requestPermission().catch(() => 'default');
            if (perm !== 'granted') {
              try { localStorage.setItem(AUTO_PROMPT_DISMISSED, '1'); } catch(_) {}
              return;
            }
          }

          // اگر اجازه داده شد، ادامه بده
          if (currentPerm === 'granted' || Notification.permission === 'granted') {
            let reg = await navigator.serviceWorker.getRegistration('{{ url_for("express_partner.service_worker") }}');
            if (!reg) {
              reg = await navigator.serviceWorker.register('{{ url_for("express_partner.service_worker") }}', { scope: '/express/partner/' }).catch(() => null);
            }
            if (!reg) return;

            // بررسی subscription موجود
            const existing = await reg.pushManager.getSubscription().catch(() => null);
            if (existing) {
              try {
                const subObj = existing.toJSON();
                const res = await fetch('/api/push/subscribe', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  credentials: 'same-origin',
                  body: JSON.stringify(subObj)
                }).catch(() => null);
                if (res && res.ok) {
                  try { localStorage.setItem(NOTIFICATION_AUTO_ENABLED_FLAG, '1'); } catch(_) {}
                }
              } catch(_) {}
              return;
            }

            // ایجاد subscription جدید
            try {
              const sub = await subscribePush();
              if (sub) {
                await saveSubscription(sub);
                try { localStorage.setItem(NOTIFICATION_AUTO_ENABLED_FLAG, '1'); } catch(_) {}
                try {
                  window.dispatchEvent(new CustomEvent('vinor:express-notifications-auto-enabled', { detail: { success: true } }));
                } catch(_) {}
              }
            } catch(err) {
              console.debug('Auto-enable notifications failed:', err);
            }
          }
        } catch(err) {
          console.debug('Auto-enable notifications error:', err);
        }
      }

      // اجرای خودکار هنگام بارگذاری صفحه
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(autoEnableNotificationsInBackground, 2000);
        });
      } else {
        setTimeout(autoEnableNotificationsInBackground, 2000);
      }

      // تلاش خودکار برای ثبت پوش اگر قبلاً اجازه داده شده
      document.addEventListener('DOMContentLoaded', async () => {
        try {
          if (!('serviceWorker' in navigator)) return;
          const perm = (Notification && Notification.permission) || 'default';
          if (perm === 'granted' && VAPID_PUBLIC_KEY) {
            const reg = await navigator.serviceWorker.getRegistration('{{ url_for("express_partner.service_worker") }}');
            if (reg) {
              const existing = await reg.pushManager.getSubscription();
              if (!existing) {
                try { 
                  const sub = await subscribePush(); 
                  await saveSubscription(sub); 
                } catch(_){}
              } else {
                // اگر subscription موجود است، آن را در سرور ثبت کن
                try {
                  const subObj = existing.toJSON();
                  await fetch('/api/push/subscribe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify(subObj)
                  });
                } catch(_){}
              }
            }
          }
        } catch(_){}
      });
    })();
  </script>

  <script>
    window.VINOR_NOTIFY_CFG = {
      enabled: {{ 'true' if session.get('user_phone') else 'false' }},
      endpoints: {
        list: "/express/partner/api/notifications",
        unread: "{{ url_for('express_partner.get_unread_count') }}",
        markAll: "{{ url_for('express_partner.mark_all_notifications_read') }}",
        markOneTemplate: "{{ url_for('express_partner.mark_notification_read', notif_id='__ID__') }}"
      },
      csrfToken: "{{ csrf_token() }}"
    };
  </script>

  <script>
    (function(){
      const cfg = window.VINOR_NOTIFY_CFG || {};
      const enabled = cfg.enabled === true || cfg.enabled === 'true';
      const endpoints = cfg.endpoints || {};
      const headers = {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      };
      if (cfg.csrfToken) {
        headers['X-CSRFToken'] = cfg.csrfToken;
      }

      const state = {
        notifications: [],
        unread: 0,
        loading: false
      };
      let pollTimer = null;
      let bootstrapped = false;

      function cloneState() {
        return {
          notifications: (state.notifications || []).map(n => ({ ...n })),
          unread: state.unread,
          loading: state.loading
        };
      }

      function dispatch(name, detail) {
        window.dispatchEvent(new CustomEvent(name, { detail }));
      }

      async function fetchNotifications(force = false) {
        if (!enabled) {
          if (!bootstrapped) {
            state.notifications = [];
            state.unread = 0;
            state.loading = false;
            dispatch('vinor:notifications:update', cloneState());
            bootstrapped = true;
          }
          return [];
        }
        if (state.loading && !force) {
          return state.notifications;
        }
        state.loading = true;
        dispatch('vinor:notifications:update', cloneState());
        try {
          const res = await fetch(endpoints.list, { credentials: 'same-origin' });
          if (!res.ok) {
            if (res.status === 401) stopPolling();
            return [];
          }
          const data = await res.json();
          if (!data.success) return [];
          state.notifications = Array.isArray(data.notifications) ? data.notifications : [];
          state.unread = Number(data.unread_count || 0);
          dispatch('vinor:notifications:update', cloneState());
          bootstrapped = true;
          return state.notifications;
        } catch (err) {
          console.warn('Vinor notifications fetch failed', err);
          return [];
        } finally {
          state.loading = false;
          dispatch('vinor:notifications:update', cloneState());
        }
      }

      function startPolling() {
        if (!enabled) return;
        stopPolling();
        pollTimer = setInterval(fetchNotifications, 30000);
      }

      function stopPolling() {
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      async function markAll() {
        if (!enabled) return;
        try {
          const res = await fetch(endpoints.markAll, {
            method: 'POST',
            headers,
            credentials: 'same-origin'
          });
          const data = await res.json();
          if (data.success) {
            state.notifications = state.notifications.map(n => ({ ...n, is_read: true }));
            state.unread = 0;
            dispatch('vinor:notifications:update', cloneState());
          }
        } catch (err) {
          console.warn('Vinor notifications markAll failed', err);
        }
      }

      async function markRead(id) {
        if (!enabled || !id || !endpoints.markOneTemplate) return;
        try {
          const url = endpoints.markOneTemplate.replace('__ID__', encodeURIComponent(id));
          const res = await fetch(url, {
            method: 'POST',
            headers,
            credentials: 'same-origin'
          });
          const data = await res.json();
          if (data.success) {
            state.notifications = state.notifications.map(n => n.id === id ? { ...n, is_read: true } : n);
            state.unread = Number(
              data.unread_count !== undefined ? data.unread_count : Math.max(0, state.unread - 1)
            );
            dispatch('vinor:notifications:update', cloneState());
          }
        } catch (err) {
          console.warn('Vinor notifications markRead failed', err);
        }
      }

      window.VinorNotifyCenter = {
        getState: cloneState,
        fetchList: fetchNotifications,
        markAll,
        markRead
      };

      window.addEventListener('vinor:notifications:mark-all', () => {
        markAll();
      });

      if (enabled) {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            fetchNotifications(true);
          }
        });
        window.addEventListener('focus', () => fetchNotifications(true), { passive: true });
        fetchNotifications(true);
        startPolling();
      } else {
        dispatch('vinor:notifications:update', cloneState());
      }

      document.addEventListener('alpine:init', () => {
        Alpine.data('vinorNotifyBadge', () => ({
          unreadCount: 0,
          loading: true,
          init() {
            this.sync(VinorNotifyCenter.getState());
            this._onUpdate = (evt) => this.sync(evt.detail);
            window.addEventListener('vinor:notifications:update', this._onUpdate);
            VinorNotifyCenter.fetchList(true);
          },
          destroy() {
            if (this._onUpdate) {
              window.removeEventListener('vinor:notifications:update', this._onUpdate);
            }
          },
          sync(state) {
            if (!state) return;
            this.unreadCount = state.unread || 0;
            this.loading = !!state.loading;
          },
          badgeLabel() {
            if (!this.unreadCount) return '';
            return this.unreadCount > 99 ? '99+' : String(this.unreadCount);
          }
        }));

        Alpine.data('vinorNotificationsPage', (initialList = [], initialUnread = 0) => ({
          items: Array.isArray(initialList) ? initialList : [],
          unreadCount: Number(initialUnread || 0),
          loading: false,
          init() {
            // اگر initial data وجود دارد، از آن استفاده کن
            if (Array.isArray(initialList) && initialList.length > 0) {
              this.items = initialList;
              this.unreadCount = Number(initialUnread || 0);
              this.loading = false;
            } else {
              // در غیر این صورت، از state موجود استفاده کن
              const currentState = VinorNotifyCenter.getState();
              if (currentState && currentState.notifications && currentState.notifications.length > 0) {
                this.items = currentState.notifications;
                this.unreadCount = currentState.unread || 0;
                this.loading = false;
              } else {
                // اگر هیچ داده‌ای نیست، loading را true کن و fetch کن
                this.loading = true;
              }
            }
            
            // تنظیم event listener برای به‌روزرسانی‌های بعدی
            this._onUpdate = (evt) => this.sync(evt.detail);
            window.addEventListener('vinor:notifications:update', this._onUpdate);
            
            // همیشه fetch کن تا داده‌های جدید را بگیر
            VinorNotifyCenter.fetchList(true);
          },
          destroy() {
            if (this._onUpdate) {
              window.removeEventListener('vinor:notifications:update', this._onUpdate);
            }
          },
          sync(state) {
            if (!state) return;
            this.items = state.notifications || [];
            this.unreadCount = state.unread || 0;
            this.loading = !!state.loading && !this.items.length;
          },
          markAll() {
            VinorNotifyCenter.markAll();
          },
          markRead(notif) {
            if (!notif || !notif.id) return;
            VinorNotifyCenter.markRead(notif.id);
          },
          openLink(url) {
            if (url) window.location.href = url;
          },
          formatDate(ts) {
            if (!ts) return '';
            try {
              const value = typeof ts === 'number' ? ts : Number(ts);
              const date = String(value).length > 10 ? new Date(value) : new Date(value * 1000);
              if (isNaN(date.getTime())) return '';
              return date.toLocaleString('fa-IR', {
                timeZone: 'Asia/Tehran',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              });
            } catch {
              return '';
            }
          },
          iconClass(type) {
            if (type === 'success') return 'fa-check-circle text-green-500';
            if (type === 'warning') return 'fa-exclamation-triangle text-amber-500';
            if (type === 'error') return 'fa-times-circle text-red-500';
            return 'fa-info-circle text-blue-500';
          },
          iconWrapper(type) {
            if (type === 'success') return 'bg-emerald-100 text-emerald-600 dark:bg-emerald-900/30';
            if (type === 'warning') return 'bg-amber-100 text-amber-600 dark:bg-amber-900/30';
            if (type === 'error') return 'bg-rose-100 text-rose-600 dark:bg-rose-900/30';
            return 'bg-blue-100 text-blue-600 dark:bg-blue-900/30';
          }
        }));
      });
    })();
  </script>

  {% block scripts %}{% endblock %}
  
  <!-- Onboarding Tour System -->
  <script src="{{ url_for('static', filename='js/onboarding.js') }}"></script>
  
</body>
</html>


